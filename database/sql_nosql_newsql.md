# SQL NoSQL NewSQL

`SQL`作为主要的数据存储方式已经超过40年，并且经历了至少两个指数扩张期：20世纪90年代`Web`应用程序崛起之后，以及在过去十年中由于移动设备爆炸引起的扩张。 因此，越来越小的公司开始发现使用数据库的好处，而像Google这样的互联网巨头则已经将数据单位上升到PB或甚至EB。

在`SQL`的发展过程中，产生了许多迭代产品，其中最重要的是`SQL`，`NoSQL`和`NewSQL` — 它们一起负责绝大部分的数据库市场。

所以，如果你要选择一个数据库工具，你应该选择哪一个？ 其实，没有明确的答案。 不同的人和公司选择不同，这更多地取决于他们对每个特定项目的偏好和相对优势，而不是其中一个对其他所有的直接优势。 那么，这些优点和缺点是什么？ 让我们来看一下。

## SQL

`SQL`是关系型数据库管理系统（`RDBMS`），顾名思义，它是围绕关系代数和元组关系演算构建的。 70年代以来，它一直是主要的数据库解决方案，只是最近才有了其他产品的空间。 不管有些人说什么，这意味着它一直能出色地执行广泛的任务。 其主要优点如下：

* 不同的角色（开发者，用户，数据库管理员）使用相同的语言。
* 不同的`RDBMS`使用统一标准的语言。
* SQL使用一种高级的非结构化查询语言。.
* 它坚持`ACID`准则 (原子性，一致性，隔离性，持久性),，这些准则保证了数据库尤其是每个事务的稳定性，安全性和可预测性。

如你所见，许多`SQL`的好处来源于它的统一性，舒适性和易用性。 即使你只有非常有限的SQL知识（或完全没有，如果需要），你可以在像`online SQL Query Builder`这样的特殊工具帮助下使用它。

然而，它的缺点使得它非常不适合某些类型的项目。 `SQL`的主要问题是它难以扩展，因为它的性能随着数据库的变大而快速下降。 分布式也是有问题的。

`NoSQL`和`NewSQL`出现的原因之一是，以前的`RDBMS`的设计不能满足现代数据库每秒处理的事务数量。 像亚马逊或阿里巴巴等需要处理惊人数据量的巨头，以前的`RDBMS`会在几分钟内出现问题。

## NoSQL (Not Only SQL)

`NoSQL`越来越受欢迎，其中最重要的实现是`Apache Cassandra`，`MongoDB`等产品。 它主要用于解决SQL的可扩展性问题。 因此，它是没有架构的并且建立在分布式系统上，这使得它易于扩展和分片。

然而，这些好处是以放宽`ACID`原则为代价的：`NoSQL`采取最终一致性原则，而不是所有四个参数在每个事务中保持一致。 这意味着如果在特定时间段内没有特定数据项的更新，则最终对其所有的访问都将返回最后更新的值。 这就是这样的系统通常被描述为提供基本保证的原因（基本可用，软状态，最终一致性） — 而不是`ACID`。

虽然这个方案极大地增加了可用时间和伸缩性,它也会导致数据丢失----这个问题的严重程度取决于数据库服务器的支持情况和应用代码质量.在某些情况下,这个问题十分严重.

另一个`NoSQL`出现的问题是现在有很多类型的`NoSQL`系统,但它们之间却几乎没有一致性.诸如灵活性,性能,复杂性,伸缩性等等特性在不同系统间差别巨大,这使得甚至是专家在他们之间都很难选择.不过,当你根据项目特点作出了合适的选择,NoSQL可以在不显著丢失稳定性的情况下提供一个远比SQL系统更高效的解决方案.

## NewSQL

`NewSQL`是一种相对较新的形式，旨在使用现有的编程语言和以前不可用的技术来结合`SQL`和`NoSQL`中最好的部分。 `NewSQL`目标是将`SQL`的`ACID`保证与`NoSQL`的可扩展性和高性能相结合。

显然，因为结合了过去仅单独存在的优点，`NewSQL`看起来很有前途; 或许，在未来的某个时候，它将成为大多数人使用的标准。 不幸的是，目前大多数`NewSQL`数据库都是专有软件或仅适用于特定场景，这显然限制了新技术的普及和应用。

除此之外，`NewSQL`在每个方面比较均匀，每个解决方案都有自己的缺点和优势。 例如，`SAP HANA`可以轻松处理低到中等的事务性工作负载，但不使用本机集群，`MemSQL`对于集群分析很有用，但在`ACID`事务上表现出较差的一致性，等等。 因此，在这些解决方案变得真正普及之前，可能还需要一段时间。

## 结论

围绕`SQL`有许多谬见和误解：例如，`SQL`已过时，应该尽可能替换为`NoSQL`或`New SQL`。 当然，这不是真的。 目前，在三种基本替代方案中没有明确的领导者 - 每一种都有更适合的项目，而在其他情况下不太适合（或完全不适合）。 因此，没有普遍的理想选择。 例如，如果你主要考虑数据库应始终可用于接受新的内容，则应考虑最终一致性解决方案，如`Cassandra`或`Riak`。 如果你追求高速缓存`SQL`，新的缓存数据库比如`VoltDB`似乎是明智的选择; 等等。

## 思考

如果这是对的话, 那么分布式关系型数据库本身就是一个伪命题. `NoSQL`的出发点就是`SQL`不能简单横向扩展, 另外横向扩展能力与`ACID`好像是矛盾的. 所以, 至少在现在来看, 要分布式就是`NoSQL`, 并不存在分布式的`SQL`.

## 额外

### 关系型数据模型

关系型数据库中的每一条记录存储都需要遵守一个固定的模式----固定的列数，每一列都是有特定的意义而且规定了数据类型。如果要获取不同的数据，数据库的模式就需要重新修改。

此外，关系型模型还有一个特点就是“数据库标准化”，也就是大的表会被压缩成小的、整合的表. 通过一对一, 一对多, 多对多的模式.

在关系模型当中，多个表中的不同记录经常“交错连接”，一些数据会被多条记录共享。这样的好处就是减少了重复数据的出现，但是这样不好的地方就是一旦其中某一条链接的记录发生改变，那么与其相关的记录和表都会被锁住以防止非一致性的出现。 ACID事务在关系型数据库中是很复杂的，因为数据会扩散。即便是单一条记录，这复杂的共享数据内部关系网的存在，也使得关系型数据在多个服务器之间的传递变得复杂而缓慢，同时让读和写操作的性能变差。

当存储空间昂贵又稀少时，折中的权衡方案是很必要的。然而，如今存储空间的价格跟40年前相比已经大大的下降了，很多时候计算折中方案已经完全没有必要。使用更多的存储空间来换取更好的操作性能，或者是将工作负载分配到多台机器上，这才是如今应用上更好的解决方案。

### 文档型数据模型

“文档型数据模型”真的和传统意义的文字“文档”没有什么关系。他不是书、信或者文章，这里说的“文档”其实是一个数据记录，这个记录能够对包含的数据类型和内容进行“自我描述”。XML文档、HTML文档和JSON 文档就属于这一类。SequoiaDB就是使用JSON格式的文档型的数据库，它的存储的数据是这样的：

```json
{
  "ID": 1,
  "NAME": "SequoiaDB",
  "Tel": {
    "Office": "123123", "Mobile": "13132"
  },
  "Addr": "China, GZ"
}
```

可以看到，数据是不规则的，每一条记录包含了所有的有关“SequoiaDB”的信息而没有任何外部的引用，这条记录就是“自包含”的。这就使得记录很容易完全移动到其他服务器，因为这条记录的所有信息都包含在里面了，不需要考虑还有信息在别的表没有一起迁移走。同时，因为在移动过程中，只有被移动的那一条记录（文档）需要操作而不像关系型中每个有联系的表都需要锁住来保证一致性，这样一来ACID的保证就会变得更快速，读写的速度也会有很大的提升。

### 灵活性

即非结构化数据

如今的社交网站越来越普及，而随着用户量不断壮大，每个用户的使用方式或者是发布的内容类型都不尽相同。有人会发布风景照片、有人发布对时事的评论还有人分享音乐表达心情。面对如此大量而多样性的数据，如果使用关系型模型，就需要不断你的修改数据操作模式，这样，可能会引起系统负载的大大提升，同时也会大大增加处理的时间。

这时，文档型模型存储就凸显其优点了，面对复杂多变的数据，使用文档型模型就直接保留了原有数据的样貌，不需要另外创建新的表新的操作模式来处理，这样不仅存储直接快速，再过后调用时，也可以做到“整存整取”，不需要关系型模型那样再到各种链接的表上取出需要显示的记录。在RDBMS中，需要尽可能的标准化数据。而在NoSQL中，则是可以尽可能的对数据“去标准化”。

### 并发性

在社交网络当中，用户的操作量很大，许多人每天会花很多的时间泡在社交网络之中。使用传统关系数据模型时，例如，两个用户的发布信息同时链接到了“地点”，那么其中一个人回头修改自己的发布时，因为链接到了“地点”表，系统为了保证一致性就会把“地点”表锁住不让其他用户同时提出修改，这时另外的用户暂时就没办法操作“地点”表了。

如果使用文档型模型，每个人的发布就是独立的一个“文档”，这一个文档文件就包含了这一条发布的所有信息。因为这种“自包含”的特性，不同的用户修改数据只需要修改自己的文档而不会影响别人的操作。这样就实现了高的并发性！

### 名词

`OLTP`: `On-Line Transaction Processing`, 联机事务处理系统

`Redies`: 主要用于高速内存缓存数据应用.

在众多`NoSQL`中, 只有`Hbase`跟`hadoop`生态紧密结合.