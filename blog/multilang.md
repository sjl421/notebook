# 语言杂谈

我不研究`PL`, 也没写出什么NB的项目, 写过的代码加起来也没1万行. 因此, 这里所谈的内容没什么指导意义, 纯属个人瞎扯. 

我自学过多种语言, 准确的说, 这些语言的入门书箱都看过, 里面的示例代码都敲过, 很多都不求甚解. 我不是什么天才, 那些号称一法通万法通的人, 我一向羡慕.这些年来, 我只做到了以万法通一法.

## 抽象能力

学多语言的收获一, 语言的主要差别是抽象能力.

具体的表现上, 就是代码重用的度. 以`C`语言为例, `C`提供了3种代码重用的层次: 第一层是函数, 所谓函数就是语句的集合, 通过参数和返回值来与外部交互. 第二层是模块, 或者说函数和变量的集合, 具体点表现为`C`的头文件及实现文件. 包含头文件时, 同时引入了多个函数. 第三层是库, 或者说模块的集合, 具体点表现为同文件夹下的头文件及实现文件. 源码上表现为`#include <lib/h1.h>`, 那个`lib`目录即库. 所有的层次都是为了代码更大程序上的重用. 函数是为了不重复自己刚写的一段代码, 模块和库是不重复利用别人写的功能函数.

以`Java`为例, `Java`也提供了3层抽象: 第一层是方法, 在类的内部包围一段代码. 第二层是类, 将数据和操作包围起来, 对数据只能进行定义的操作. 第三层是库, 即通常的`import com.enalix.example.ClassName`, 以重用别人写的类. 也有4层的说法, 但通常情况下, `Java`一个源文件即定义一个类, 所以层次是相同的. 那为什么说`Java`的抽象能力是高于`C`呢. 

扯远点, <<三体>>中, 逻辑能意识到`黑暗森林`的很大原因是叶文洁说的一句话: 将每个外星文明看作一个点, 忽略文明所有的内在细节. 如此, 去掉了所有干扰因素, 才能进行更有效更理性的思考. 可见, 将事物抽象为一个整体的能力是极其重要的, 而面向对象编程的语言给编程者提供了这种能力, 以减轻思考的负担. 在`Linux`内核中有大量自定义的结构体, 对结构体的操作很多时候都被建议使用特定函数. 这一定程度上也是将数据与其操作绑定, 即面向对象的核心思想. 

在`Java`中, 代码重用的层次是类, 编程者相对类的方法更看重类, 如果类及其方法的名称起的恰到好处, 很多时候哪个类包含哪些方法是无需记忆的, 且语言间往往是相通的. 在这点上, `C`的重用层次是函数, 编程者往往需要记忆大量的函数及其参数. 由于`C`标准库很小, 记忆的问题不大. 若`C`库跟`Java`的一样, 还能不能愉快玩耍.

但`Java`也是有问题的, 它的面向对象太过厚重, 写个`hello, world`也要创建个类. 调用个输出也要写一串方法链. 同时, 语法过于死板, 搞出许多样板写法, 令人厌烦. 也许过去的程序员刚从`C++`的折磨中解脱, 对`Java`感激涕零, 但现在的程序员以`Python`入门, 再回去`Java`就无法忍受了. 说这些, 我也丝毫不否认`Java`的伟大处, 但我就是不喜欢.

除了`Java`外, `Python`和`Ruby`的抽象层次也主要是类. 但不同的是, `Python`保留了函数的第一公民性. 你可以定义不属于任意类的函数. 虽然`Ruby`有着最纯粹的面向对象, 但你仍然可以定义函数. 函数一定属于某个对象, 但调用函数并不一定要来一串方法链. 一方面, `Ruby`将通用函数定义在模块再将模块混入基础类`Object`, 这样在任意类中都可以直接函数名调用函数, 如`puts`输出函数. 另一方面, 在脚本中创建的任意方法和变量都属于一个隐藏的`main`对象, 其类是`Object`. 

实际上, 我不这样说, 你在写`Ruby`代码的过程中, 会自然定义并使用函数, 完全不必像`Java`那样. `Ruby`的另一个特殊处是, 将代码块视为一个单独的对象. 之前有提到, 所谓函数即代码块. 匿名函数也是代码块. 代码块可作为参数传递给方法.

由上述可以看出, 面向对象的主要目的是将数据和操作关联. 也不一定要定义为类. 在新语言`Rust`中, 使用结构体类型来达成相应目的. 先定义结构体, 再为结构体实现方法. 函数是第一公民, 可自由传递. 使`trait`特征来给不同结构体混入新功能. 同时, `trait`用在范型中, 以限制方法参数的类型.

## 语法

上面提到的语言, 除了`C`外, 其实抽象能力都差不多了. 但语法上, 这是最影响程序员心情的, 却优劣明显.

对于`Java`, 很多人现在都没有意识到它和`JVM`平台并没有必然的联系. `Java`语言会死, 但`JVM`平台不会死. 这么说有些武断, 毕竟`Java`仍然在发展, 都快到9了. 但是, 语言过去的设计会在很大程度上约束语言未来的发展, 看看`C++`就知道了. 像`Java`这样的重量级语言, 是不可能轻易破坏向后兼容性的, 我想`Python`的开发团队深有体会. 所以, 与其等待`Java`加入什么新功能, 还不如赶快学习另一门基于`JVM`的语言, 如`Scala`, `Clojure`, `Kotlin`.

我在学习`Scala`, 最主要的原因是我的导师是做大数据的, 要重点使用`Spark`平台. 之后会贴一篇<<Scala基础>>, 这里只简单说几句. `Scala`的主要设计目标是混合面向对象和函数式两种编程范式. 由于<<Scala编程思想>>这本书只重点涉及了面向对象方面, 它的函数式特性我并未了解到. 待看的书箱列表中还有<<深入理解Scala>>和<<Scala函数式编程>>两本, 可能看完后会改变我这里谈的大部分观点. 对函数式编程, 我只有两点认识: 数据不可变和函数作参可传递.

`Scala`完全不是我预想的经过经心的设计, 它的语法处处透露着任性而为, 没有那种一致性的美. 更多的, 在面向对象方面, 主要是对`Java`现有语法的改进. 比如, 在值或变量, 方法的定义中加入类型推断以减少类型的键入. 通过`trait`特征来更灵活的实现功能包含. 通过`case`类来更方便只有数据域类的创建. 通过类参数来表示主构造器以减少类体代码的编写. 通过将`if`, `for`, `match`定义为表达式来方便值定义和返回. 通过更强大的`match`模式匹配来实现多分支. 去掉了基础类型的定义, 再也不用来回装箱和拆箱了. 更简单的匿名函数定义, 函数可作为对象特征参数传递. 加入`object`关键字方便单件类的定义. 加入`REPL`工具和脚本运行的能力以方便快速开发. 还有更多更细微的, 我也没开发过什么大项目, 某些更高层次的改变我意识不到它的重要性, 自然也谈不了. 对了, 文件名终于不用等于定义的公开类名了, 文件也可以定义多个类了. 是不是瞬间觉得`JVM`平台如此美好. 在写的舒服的同时, 也可以享受`JVM`无与伦比的运行速度. 

所有语言中, 我对`Ruby`语言了解最多. 它语法的简洁和一致性很难让人相信这是跟`Java`一个时代的. 如果我说, `Ruby`的设计透着一股和谐自然之美. 你可能觉得很玄. 但如果我告诉你, 这语言的设计目的是让程序员更快乐, 你肯定看我像江湖郎中了. 但我很负责地, 以我能想到的所有神明的名义发誓, `Ruby`有着所有语言中最美的语法.

`Ruby`的设计借鉴了`Lisp`的宏, 借鉴了`Perl`的正则, 借鉴了`Smalltalk`纯粹的面向对象, 也借鉴了`Python`. 按理来说, 拿别人这么多东西, 应该乱七八糟. 但松本先生却极其自然的将所有特性融合在一起. 以至于我觉得, 先生是从未来穿越来的. 哦, 后来他写了本书叫<<代码的未来>>. 

要理解`Ruby`就要理解一句话, `Ruby`中一切皆对象. 虽然很多语言也这样声称, 但只有`Ruby`是真的. 类, 方法, 模块, 实例对象, 都是表面的, 是戏法, 是幻觉. 一切都是对象, 值是对象, 类是对象, 模块也是对象. 是对象就有数据域和方法域. `Ruby`遵循一致的方法链查找. `Ruby`的类体系有点绕: 所有类(作为类)的超类是`BasicObject`类, 所有类(作为对象)的类是`Class`类. 也就是说, `BasicObject`是`Class`的超类, `Class`是`BasicObject`的类.

来说点`Python`的. `Python`设计准则是明确和实用. `Python`支持面向对象, 但也提供了全局函数. 强制性的缩进是它主要的特色. 被广泛使用的原因是它那号称包含电池的库. 在科学计算上目前甩了`Ruby`几条街. 计算上的优势, 也让`Python`在最热的大数据, 神经网络, 机器学习方面占据一席之地, 以至于松本先生眼红的提出`Ruby`的三大目标之一是发展在科学计算上的库. 等等, 这里不是谈论语法吗? 说了呀, 缩进, 其他的没特色. 

这里下个断言, 任意`Python`库用`Ruby`重写后都能提供更简洁一致的语法. 看看`Sinatra`和`Flastk`. 

在静态编译语言中, 目前认为`Rust`的语法最好. 它加入了类型推断, 使用结构体类型. 通过特殊类型让错误处理更简洁. 关键字都使用简写, 神啊, 得少敲多少字啊. 没学`Rust`前, 宣传说它能做到安全, 并发和速度的完美结合, 我以为它能发明了什么NB的语法, 我只要像过去写`C`那样就能写出安全并发速度的代码. 毕竟太年轻. `Rust`的语法很复杂, 很严柯, 因为它要让所有运行时可能发生的错误在编译时检测出来. 按理说, 我学了这么多语言, 不可能还有什么概念是别的语言对应不上的. 但`Rust`搞了个`OwnerShip`系统. 相应的, 有个`lifetime`概念. 据说, 它的字符串指针有6种. 为什么据说呢, 因为学到现在我就会个`hello, world`.

其实, 抛开动静态和强弱类型来谈语法都是在耍流氓. 静态类型语言很能比动态的更优雅, 强类型语言总需要显式的类型转化. 支持更多范式编程的语言总是更加复杂. 所以, 选择语言还是要看实际需要, 除非你和我一样蛋疼.   

## 名称

据说, 起名是程序员最大的痛苦. 少年, 你是用英文单词还是汉语拼音? 反正我知道有个程序员专门写了个软件用于生成可能的变量名, 但好像不支持中文.  其实, 编程语言发展到现在, 变量名就那么几种类型, 小写`var`, 首字母大写`Var`, 驼峰写法`TwoWord`, `twoWord`, 下划线写法`two_word`.

方法名非常重要, 简洁的方法名利于记忆和推测. 这里以`Ruby`为例: `Ruby`中所有类都提供到字串的转换`to_s`, 不知比`toString`高出多少. 一个可能看不出, 那么`find_by_age_with_index`和`findByAgeWithIndex`呢. 还有类似的到整数的转换`to_i`, 到符号的转换`to_sym`, 到浮点数的转换`to_f`. 另外, 所有集合(即包含多种元素的类型)都定义有`each`方法来遍历元素. 若同时需要索引, 则`each_with_index`. `Python`中好像使用`enumerate(ary)`. 有`!`后缀的方法表示会改变对象, 有`?`后缀的表示返回布尔值. 在`Rails`的开发中, 有大量的数据库查询方法名为`find_by_xxx`.

`Ruby`类的实例变量以`@var`表示, 一举解决了`Python`中蛋疼的`self`参数. `Ruby`重载`+`操作符, `def +(other) { return self + other.field }`, 在`Python`中为覆盖`__add__`方法. `Scala`更灵活, 方法名可以为任意符号, 你定义`@#(&^`也能运行. `Scala`你这么牛, 你爸知道吗.

## yield

是的, 很多语言都有`yield`. 细节上, 每个语言上的`yield`功能都不相同. 但大体的意思是将其后的值抛出方法外, 处理后再返回原位置.

`Ruby`中, `yield val`将某值抛给方法的块参数, 赋予其变量, 在块参数中处理完后再返回函数内.

```rb
def my_each(ary)
    ary.each do |i|
        yield i
    end
end
my_each([1, 2, 3, 4]) {|x| puts "> " + x.to_s}
```

`Python`中, `yield val`用于将方法变成生成器. 可以对生成器调用`next(gen)`来获取下一个元素.

```py
def my_each(ary):
    for x in ary:
        yield x
a = my_each([1, 2, 3, 4])  #生成器
next(a)  #1
next(a)  #2
```

当然要连续处理的话, 再将`next(gen)`放入循环中, 注意捕获终止异常以结束循环.

`Scala`中, `yield n`在`for`表达式中, 返回序列.

```scala
def my_each(ary: Seq[Int]) =
    for (i <- ary)
        yield "> " + i
val a = my_each(Vector(1, 2, 3, 4))  //字串向量, Vector("> 1", "> 2", "> 3", "> 4")
```

感觉这邦语言都快把`yield`玩坏了.

## lambda

被视为函数式编程的象征, 好像有了`lambda`关键字就支持函数式编程了一样. too young.

`Ruby`中, `lambda`用于创建`Proc`对象. 与通过`def`定义的函数不同.

```rb
add_two = lambda {|x| x+2 }
add_three = ->(x) {x+2}  #简化形式
add_two.(3)  #5
add_two[3]   #5
add_two.call(3)  # 5
```

`Scala`中, 其实没有`lambda`关键字, 但也支持匿名函数.

```scala
val add_two = (n: Int) => n+2
add_two(3)  //5
```

`Python`中, `lambda`创建匿名函数, 与通过`def`定义的函数相同.

```py
add_two = lambda x: x+2
add_two(2)  #4
```