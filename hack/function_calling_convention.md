# 调用约定

调用约定通常是特定于语言,编译器和CPU的. 

如果输出函数(如库函数)是为了供其他程序员使用, 那么它必须遵照主流的调用约定, 以便程序员能够轻松调用这些函数. 但如果仅供内部程序使用, 则随意.

`优化代码`, `定制汇编语言代码`和`系统调用`都不满足主流的调用约定. 

遵循用于Intel 32位处理器的系统V应用程序二进制接口的函数可以修改`eax,ecx,edx`寄存器, 但需要为所有其他寄存器保留调用方的值.

其于`ebp`的栈帧, 正偏移量用于访问函数参数, 而负领衔量则用于访问局部变量.

## C调用约定

修饰符: `_cdecl`

约定: 调用方按从右到左的顺序将函数参数放入栈中, 在被调用的函数完成其操作时, 调用方负责从栈中清除参数. 

优点: 函数被调用时,第一个参数将始终位于栈顶, 非常适用于那些参数数量可变的函数. 且调用方清楚知道传递的参数数量, 适合作栈调整.

对函数`void demo_cdecl(int w, int x, int y, int z);`的调用, 对应的汇编码如下.

windows系统, vc编译器:
```
push 4
push 3
push 2
push 1
call demo_cdecl
add esp, 16  ;栈平衡
```
Linux系统, gcc编译器:
```
mov [esp+12], 4
mov [esp+8], 3
mov [esp+4], 2
mov [esp], 1
call demo_cdecl
```
函数序言阶段, 编译器已经在栈顶为参数预先分配了存储空间, 因此不需要栈平衡.

## 标准调用约定

windows平台的`_stdcall`调用.

相应函数原型: `void _stdcall demo_stdcall(int w, int x, int y);`

约定: 从右到左的顺序将函数参数放在程序栈上, 函数结束执行时, 应由被调用的函数负责删除栈中的函数参数. 利用`ret n`指令.

根据惯例, 微软对所有由共享库(DLL)文件输出的参数数量固定的函数使用`stdcall`约定.

## fastcall约定

`stdcall`约定的一个变体, 其向CPU寄存器(`ecx, edx`)最多传递两个参数, 其余保存在栈中.

原型: `void fastcall demo_fastcall(int w, int x, int y, int z);`

可能生成汇编码:
```
push 4
push 3
mov edx, 2
mov ecx, 1
call demo_fastcall
```

## C++调用约定

C++类中的非静态成员函数需要使用`this`指针, 指向用于调用函数的对象.

VC++提供`thiscall`调用约定, 将`this`传递到`ecx`寄存器中, 并且和`stdcall`中一样, 由非静态成员函数清除栈中的参数.

g++编译器将`this`看成是任何非静态成员函数的第一个隐含参数, 而在所有其它方面与使用`cdecl`约定相同.

## 64位平台

在x86_64位系统中，由于寄存器的数量得到了提升，因此对于函数调用中的参数传递，优先使用寄存器进行传递，只有在参数个数多于一定数量时才会使用压栈的方式，同时这个传递也是有一定顺序的, `edi，esi，edx, ecx, r8, r9, 栈传递`