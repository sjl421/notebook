# vim extra

`vim -u fname`, 以指定文件替代`~/.vimrc`作为启动配置.

`vim -u NONE -N`, 不加载用户匹配文件, 设置`nocompatible`.

`vim --version`和`:version`都可以列出版本和编译的功能列表.

`>G`, 增加当前行到文档末尾处的缩进层级. `>>`为缩进当前行. 相反的`<`. `=`为自动缩进, 即格式化.

`.`, 重复上次修改. 这里的修改是切实改变了文本的内容, 并不包括光标位置的改变. 如删除(`x`, `dd`), 缩进(`>`), 插入(`iaaa<esc>`)等.

为源码行尾添加`;`号, 执行`A;<esc>`后, `j.`下一行再重复.

`0`到行首, `^`到字串首.

`A`在行尾插入, `I`在字串首插入. `C`删除到行尾插入, `S`删除整行插入. `s`删除光标字符插入.

给操作符两侧加空格: 对于字串`hello+world+enalix`, 执行`f+`定位到`+`, 执行`s + `给`+`两侧加空格, 执行`;`重复`f+`操作, 定位下一个`+`, 再`.`重复`s + `操作.

单行字符查找: `f+`定位到`+`, `t+`定位到`+`前字符, `F/T`表示反向查找, `;`重复查找下一个字符, `,`则查找上一个字符. 这就表现为, 在`+`字符组成的链表上, `,`向前跳, `;`向后跳.

全文模式匹配: `/pattern`或`?pattern`. 在匹配的字串组成的链表中, `n`向后跳, `N`向前跳.

替换操作: `:s/old/new/`, 执行`&`替换下一个, `u`回复.

查找并手动替换: `*`查找光标下的单词, 相当于`/\<word\>`, 在执行替换匹配字串时, 可省略匹配(`:%s//new/g`). `cwnew<esc>`删除光标单词并输入`new`回到普通模式, `n/N`跳跃, `.`重复替换.

使用`.`的技巧主要是, 定位(`f`,`*`), 修改, 重复字位(`n/N`, `,/;`), `.`重复修改.

`i{some text}<esc>`, 输入一些文字并返回普通模式, 是一次修改, 用`u`撤销. 可以通过控制`<esc>`的时机, 来控制撤销的粒度. 通常, 可以让每个"可撤销块"对应一次思考过程.

`b/e`总是跳到本word的首/尾字符, `w`跳到下一个word的首字符.

删除一个单词, 无论光标位于word的何处, `daw`.

对一个数字执行`<C-a>`和`<C-x>`, 可加1或减1. 加数字前缀可加减特定数. 事实上, 会自动定位右侧最靠近的数字, 而不只有在数字才生效. 能自动识别`007`以0开头的为八进制, `0x110`以0x开头的为十六进制, `0b111`以0b开头的为二进制, 并能正确处理好进位借位. 这取决于`nrformats`选项. 默认为`bin,octal,hex`. 若包含`alpha`, 则能处理字母的上一个下一个.

`.blog`, 光标处于`.`处, `cw`删除`.`, 而`cW`删除`.blog`. 这里涉及`w`和`W`的区别. `w`是包含字母数字下划线的word, 由`iskeyword`选项认定. 而`W`则不含空格即word.

`d2w`, `2dw`, `dw.`, 都是删除两个单词. 使用次数还是`.`重复要分情况看. 其中一个最重要的区别是`u`的撤销粒度.

`gu{motion}`, 令范围字符小写, `guu`, 令一行字符小写. 相似的有`gU`, `g~`.

文本对象: `aw`一个单词, `ap`一个段落, `as`一个句子, `at`html标签内容; `a`一般会置光标于对象后一个字符, `i`一般会置光标于对象的最后一个字符.

支持自定义操作符, `:h map-operator`. 参考插件`commentary.vim`, 提供注释操作符. `gc{motion}`添加注释, `gcc`注释一行, `gcgc`取消注释

`vim-textobj-entire`定义了全局文本对象`ae/ie`, 则结束上面插件, 注释全文`gcae`.

在插入模式下, `<C-h>`删除前一个字符, `<C-w>`删除前一个单词, `<C-u>`删除行首. 注意, 此处的删除只是删除已插入的文本, 并不影响输入法已键入的字符, 其还要用`<bs>`来删除. 但也可以作为一个特性来使用.

除了`<esc>`可返回普通模式, `<C-[>`也可以返回普通模式.  至于`<c-o>`可临时返回普通模式, 执行普通命令后, 自动返回插入模式. 比如, 在插入时`<C-o>zz`总可以临时将当前行置于屏幕正中.

关于建议将`Caps Lock`映射为`Ctrl`, 因为`<C-[>`也可以替代`<esc>`, 且经常使用`<C-a/x>`, `<C-h/w/u>`等快捷键.

在插入模式下, `<C-r>{register}`粘贴指定寄存器内容. 要注意, 在映射后, 插入模式中`Ctrl`非常常用. vim在插入寄存器内文本时, 其插入方式是由键盘上一个个输进来的. 如果设置了`textwidth`和`autoindent`, 同时候去出现不必要的换行或额外的缩进.

在插入模式下, 输入`<C-r>=`使用表达式寄存器, 等待表达式输入, 回车, 插入计算结果.

插入特殊字符, `<C-v>{xxx}`或`<C-v>u{xxxx}`, 后者插入`unicode`编码. 在任意字符上, `ga`可显示其编码. `<C-k>{char1}{char2}`插入二合字母.

`vim`的二合字母有很多, 记住常用的几个. 空集`Ø ø`, `O/ o/`; 分数`½ ⅔ ¾`, `12 23 34`; 元音注音字符`àáâã`, `a! a' a? a:`, 其它类似`aeiou/AEIOU`; 上标数字`¹ ² ³`,  `1S 2S 3S`; 中点`·`, `.M`; 二声符`´`, `''`; 书名号`« »`, `<< >>`; 倒符号`¿ ¡`, `?I !I`; `±`, `+-`; 角度`°`, `DG`; 商标`®`, `Rg`; 逻辑非`¬`, `NO`; 版权`©`, `Co`; 章节符号`§`, `SE`; `¦`, 中间断开了, `BB`; 金钱符号`¥ £`, `Ye Pd`; 除号`÷`, `-:`; 希腊字母`α β γ δ ε ζ η θ ι κ λ μ ν ξ ο π ρ σ τ υ φ χ ψ ω`, `[a-z]*`; 闪电符号`ϟ Ϟ`, `k3 K3`; 各种俄文符号`а б в г д е ж`, 大部分都是`[a-z]=`, 但`ж`, `z%`. 只有你想不到, 没有不能表示的. 查询帮助, `:digraph-table`.

对于制表符, 一个字符占据多列, 在替换时, 会改变行长度. 可以使用虚拟替换`gR`将其当成一组空格处理. 当然, 如果设置了`expandtab`, 则所有的`<tab>`都会扩展为空格, 也无需如此. 注意, 只是制表符后的字符位置不变, 虚拟替换几个字符, 剩余的空白仍然是一个制表符. 还有单次模式, `r gr`.

`viw`可以可视化一个单词, 跟`aw`的细微区别, 不会选中word后的空白.

除了`<esc>`可退出可视模式, 再按一下`v`也可退出. 在非字符可视选择外, `v`可切换到字符模式, 换句话说, `vv`总能退出可视模式.

除了`v V C-v`外, 还有个`gv`可重选上次的高亮选区. `o`可切换选区的活动端, 比如, 起始点未选择好, `o`切换到起始点, 移动光标选择, 再`o`切换到末尾点, 移动光标选择.

即使如此, 在执行重复性任务时, 尽量避免使用可视模式, 而是普通模式.

在可视模式下, 要记住`.`可重复修改, `gv`可重选选区.

可视模式下的`r`可替换每一个字符, 如`Vr-`可将一行字符全替换为`-`.

在长短不一的文本后统一添加字符, `<c-vjjj$A;<esc>`

命令行模式下, 也同插入模式一样, 支持各种特殊`<c-?>`类型的特殊键.

命令: `:[range]delete [x]`删除, 可指定范围和寄存器, 相同的有`yank`复制, `put`粘贴. `:[range]copy {address}`拷贝到指定行之下, 相似有`move`移动. `:[range]join`连接行. `:[range]normal {commands}`对指定行执行普通模式命令. `:[range]substitute/{pattern}/{string}/[flags]`在指定范围替换匹配为字串, `:[range]global/{pattern}/[cmd]`对指定范围匹配执行命令.

以上命令有简洁形式: `:d`, `:y`, `:pu`, `:co`常用`:t`, `:m`, `:j`, `:norm`, `:s`, `:g`. 相对普通模式命令一般操作当前字符或当前行, 而`Ex`命令却可以在任意位置执行. 范围一般可表示为`n1,n2`, 其中`.`表示当前行, `$`表示最后一行, `0`表示第一行, `%`表示全文.

`:p`表示回显当前行, `:print`.

单独数字定行: `:1`可定位首行, `:n`可定位第n行, `:$`可定位最后一行, `:-1`可定位倒数第1行. 可以数字接命令, 如`:3p`打印第3行, `:3d`删除第3行. 且, 删除第3行, `3Gdd`要比`:3d`多个字符. `:0`表示特殊行, 常用于`:t`或`:m`将文本拷贝或移动到首行上.

也可用模式来代表范围, 如对`html`标签, 可`:/<body>/,/<\/body>/p`打印. 注意, 只是匹配行, 而非匹配字符. 还可以加偏移, 如`:/<body>/+1,/<\/body>/-1p`, 可不打印`<body>`标签.

还可以用位置标记, `'m`, 其中`'<`常表示高亮选区的起始行, 而`'>`常表示结束行.

将当前行拷贝到首行上, `:t0`; 拷贝到最后一行, `:t$`; 将首行拷贝到当前行下, `:1t.`; 将最后一行拷贝到当前行, `:$t.`. 为当前行创建副本, `:t.`, 相当于`yyp`. 注意, 拷贝后, 光标位于拷贝处. 相似的还有`:m`, 只不过是移动文本.

给指定范围行的尾部加`;`:
* 在第1行, `A;`, 重复`j.`多次
* 块选中`<C-v>`所有行, `$`令范围包括行的所有内容, `A;<esc>`
* 在第1行`A;`, `jV`选中所有行, `:norm .`在选中区域执行重复命令`A;`.


如给文本的所有行尾加`;`, 可直接`:%norm A;`. 注释所有文本行, `:%normal i//`. 执行命令前, 光标会移动到开始行的第1列.

可以用`:norm .`应对简单的重复性工作, 用`:norm @{register}`应对复杂的任务.

`@:`重复命令行模式作出的修改, 而`.`则是重复普通模式作出的修改.

`@`通常回放寄存器存储的命令, 而`:`寄存器存储最近执行过的`Ex`命令(即在命令行中执行过的命令).

`:cmd_str<C-d>`会列出命令的可补全列表. 用`<tab>`来补全. 若设置了`wildmenu`选项, 提供一个补全导航列表, 用`<C-n/p>`来遍历列表项.

即使在命令行模式下输入命令, `vim`也知道光标位置, 可用`<C-r><C-w>`插入光标下的word. `<C-r><C-a>`是插入光标下的字串, 不同于word, 以` `空格分开的是字串.

对于命令行模式下的历史命令回溯, 除了`<up><down>`, 还可以使用`<C-n/p>`. 对于`<up/down>`, 在已经输入部分字符的情况下, 会进行过滤, 而`<C-n/p>`不进行过滤, 因此, 最好将其映射到`<up/down>`.

`q:`打开命令行窗口, `q/`打开匹配命令历史窗口, `<C-f>`从命令行模式切换到命令行窗口. 可像所有普通缓冲区一样, 区分不同模式, 执行不同模式的命令, 除了`<cr>`回车执行外.

`:update`, `:up`, 当且仅当缓冲区有修改时被写入, 略不同于`:w`.

连接多个`Ex`命令: `:up | !ruby %`. 比如对于`Java`单文件, 可以执行`:up | !javac % && java %:r`, 保存源码, 编译, 执行. 再利用`@:`来重复.

虽然提供了`:shell`命令进入交互式`shell`, 用`<c-d>`退出返回`vim`. 但在终端下, 可以使用`<c-z>`挂起`vim`, 用`fg`将`vim`作业切换到前台. 两者实现相同的功能.

`:r !{cmd}`将外部命令输出读入缓冲区, `:w !{cmd}`将缓冲区内容输出到外部命令. 比如想运行`ruby`代码, 除了`:!ruby %`, 还可以`:w !ruby`.

当`:!{cmd}`有范围时, 会表现为一种过滤性质. 将范围文本, 由命令修改后, 再输出回范围. 如对格式数据进行字段排序, `:n1,n2!sort -t',' -k2`, 其中`-t`指定分隔符, `-k`指定字段. 除了手写范围外, 还可以在光标行, `!G`表示选中当前行到文末, 再输入`sort ...`.

编辑多文件时, `vim *.txt`, 虽然只能看见一个文件, 但其它文件也载入了缓冲区. 通过`:ls`列出缓冲区文件列表, 通过`:bn/bp`打开下/上一个文件, 通过`bf/bl`打开第一个最后一个文件. 通过`:b {num/fname}`打开指定的缓冲区, 其中缓冲区名可以自动补全. 通过`:bd n1 n2 n3`删除指定缓冲区, 或`:n1,n2bd`删除缓冲区范围. 

可以在启动`vim`后再添加要编辑的文件列表, 如`:args **/*.js **/*.css`会将当前目录及其子目录下所有的`.js`和`.css`文件添加到当前的文件列表中. 或者, 你可以将要编辑的文件名写入文件中(假设为`.file`), 执行`:args \`cat .file\``, 先执行`shell`命令, 再将输出结果作为条目加入文件列表. 换句话说, `\`\``可以运行`shell`命令.

注意, 带参数的`args`命令会清空并重新设置当前的缓冲区列表.

对于参数列表, 最开始的意思即`vim`启动时传递的参数文件, 但增强后的概念, 基本同缓冲区列表. 只是可以批量设置. 缓冲区列表包含参数列表, 认定参数列表只会清空当前的参数列表, 只会增加缓冲区列表而不会减少.

参数列表使用`next/prev`遍历, 用`:argdo`对列表中的每个缓冲区执行同一条`Ex`命令. 虽然缓冲区也提供了类似的`:bufdo`命令, 但缓冲区列表相对文件类型较为复杂, 不如参数列表, 往往有相同的后缀特征等.

`:argdo {cmd}`类似这样工作, `:first`, `:{cmd}`, `:next`, `:{cmd}`..., 但如果修改缓冲区, 而未保存, `:next`会失败, 除非使用`:next!`. 可以设置`hidden`选项, 缓冲区被修改也可以被隐藏. 在修改完后再执行`:wa`保存所有. 注意, 此处的命令必须是`Ex`命令.

`<C-w>s`水平分隔窗口, `<C-w>v`垂直分隔窗口. 分隔的窗口仍然显示原缓冲区, 可以使用`:e`编辑新的文件. 又或者`:sp {fname}`水平分隔窗口并编辑文件, `:vsp {fname}`垂直分隔窗口并编辑文件.

通过`<C-w>h/j/k/l`上下左右切换窗口. `<C-w>c`, 或`:clo`关闭当前窗口, `<C-w>o`, 或`:on[ly]`关闭所有别的窗口.

有多个窗口后, 可以用`<C-w>_`来最大化当前窗口的高度, `<C-w>|`来最大化当前窗口的宽度. 可以加前缀数字, 来分别设定高度和宽度. 最终总可以用`<C-w>=`来恢复原样, 即所有窗口等宽等高, 即默认的等分.

认定当前窗口的当前目录, `:lcd {path}`. 但并不是针对当前标签的所有窗口, 要这样做, 可以`:windo lcd {path}`, 即对所有窗口设定.

注意, 到现在为止, 我们有`:argdo {cmd}`来对参数列表, 有`:bufdo {cmd}`来对缓冲区列表, 有`:windo {cmd}`来对当前标签的所有窗口列表.

使用`:tabe[dit] {fname}`来在新标签页打开文件, 或`<C-w>T`来将当前窗口移到新标签页. 同样有`:tabc[lose]`关闭当前标签和`:tabo[nly]`只保留当前标签.

可以通过`gt`跳转到下一标签页, 加前缀数字可以跳转到指定标签页, 如`2gt`. `gT`往相反方向跳转. 也可以使用`Ex`命令, `:tabn {N}`, `:tabp`.

可以使用`:tabm {N}`来移动当前标签页, 若`N`为0时, 将当前标签页移动到第1个, 省略`N`则移动到最后一个.

打开文件有个小技巧, 通过`:e %<tab>`可以扩展当前缓冲区文件的完整路径, 或者用`:e %:h<tab>`扩展文件的目录, 再在此基础上输入同目录的文件, 以避免输入过长的路径.

注意的一个区别是, 当前工作目录是`vim`运行的目录, 而非打开的文件所在的目录. 因此, 如果恰好在编辑一个有很深层目录的文件时, 再想编辑与其同目录的文件往往要输入同样长的目录路径, 但可以通过`%:h<tab>`来扩展补全路径.

在一个项目结构中, 不同文件位于不同层次目录中, 通过输入完整路径来打开文件极其没有效率. 可以使用`:find {fname}`查找指定文件名来打开. 但前提是文件所在的目录位于`path`变量中. 可通过`:set path+=subdir/**`来添加指定子目录下的所有子目录.

`vim`原生的目录插件`netrw`, 可用的命令包括`:E`打开文件管理器, `:Se`水平打开, `:Ve`垂直打开. 其中`e`为`explore`的意思. 但即使如此, 离`nerdtree`插件还差得远.

`<C-g>`用于显示当前缓冲区文件名及状态信息.

`:e path`是可以指定不存在的路径, 此时会创建新的缓冲区, 不同的是在执行保存`:w`会提示路径不存在. 当然, 你是可以`:!mkdir -p %:h`来创建此路径的目录的.

当我们在修改一个需要特权的文件时, 但我们并没有以`sudo`启动文件, 此时要么退出并重新特权启动, 要么可以执行`:w !sudo tee % >/dev/null`, `tee`可以将标准输入一部分写入`%`原文件, 一部分舍弃. 之后, 原文件改变, `vim`会提示文件被外部程序`tee`改动, 是否要xxx.

`vim`区分屏幕行, 对于一个很长的行, 如果开启`wrap`选项, 一个实际行对应多个屏幕行. 在屏幕行的移动, 也许你清楚`gj`和`gk`是上/下移动. 除此外, `g0`移动到屏幕行的行首, `g^`移动到屏幕行的首个非空白字符. `g$`天桥浮村过程屏幕行的行尾.

`b`的准确定义是, 反向移动到当前单词/上一单词的开头, 而`e`相反.

修改当前单词尾, `ea`; 修改单词头, `bi`; 交换两个字符, `xp`.

`vim`区分"单词"`word`和"字串"`WORD`. 后者的区分标准是空格. 也有相应的移动命令: `W/B/E`.

用好`t`, 其停留在查找字符前, 经常用于, 如删除函数的参数列表`def func(arg1, arg2) {}`, 通过在`(`光标上执行`dt)`就可以不用删除`)`.

在普通模式下, 我们使用`f/F`来定位字符, 在操作符等决模式, 如`d{motion}`或`c{motion}`, 使用`t/T`.

移动字符时, 选取出现频率较低的字符, 能加快移动效率.

有个很NB的技术, 在按`v`进入字符可视模式时, 可以通过`/?`搜索来选择字符区. 除此外, 在待决模式, 如`d{motion}`, 按`d`后, 可以直接通过`/?`搜索来选择删除区域.

文本对象必须位于对象内部, 才能使用.

对于`{}`内的文本, 如果想删除文本, `di{`, 如果连`{}`也删除, `da{`. 相似的有`di"`和`da"`, 对应`""`对象; 有`di<`和`da<`, 对应`<>`对象; 有`dit`和`dat`, 对应`html`的`<tag>...</tag>`标签. 还有`'', []`对象.

如上, 常见的闭合文本对象有`"", '', \`\`, {}, [], (), <>, <tag></tag>`. 以`i`开头的会选择分隔符内部的文本, 以`a`开头的会选择包括分隔符在内的文本.

除了上述分隔符文本对象, 还有范围文本对象. 其中主要是`w`表示单词, `W`表示字串, `s`表示句子, `p`表示段落. 再加上前缀`i/a`. 这里的区别是, `a`选择的对象, 除了对象本身还包含一个空格. 如`daw`会删除单词及其后的一个空格. 当然, 如果其后没有空格, 则不删除. 通常来说, 删除`d`跟`a`配合, 要修改`c`则跟`i`配合.

任何时候, 我们可以标记一个位置`m{a-za-z}`, 再在之后跳回标记位置. 其中, 小写字母局部于当前缓冲区, 而大写字母则在所有缓冲间跳转. 跳回缓冲区有两种: `'{mark}`定位到标记行的首个非空白符, 而`\`{mark}`则定位到离开时的字符处.

你可能会对这几个标记感兴趣, 如`''`跳转回上次光标跳转前的位置, `'<`和`'>`则标记高亮区域的上下行位置.

我们可以在成对的括号间跳转, `{} [] ()`. 用`%`. 通常要修改括号, 总是跳转到下一个括号, `r]`, 再`<c-o>`跳回起始位置, `r[`. OK, 完成修改. 如果使用了`surround.vim`插件, 可以直接`cs{[`即可.

同样, 利用`surround.vim`, 可以方便的给文本加分隔符. 如`hello`上执行`S"`即可用引号包围单词.

只有大段文本间的跳转才算跳转, 才会写入跳转列表, `:ju[mps]`.  而在跳转列表中, `<C-o>`用于返回列表的上一个位置, `<C-i>`用于跳转到列表的下一个位置. 且是全局跳转, 如你打开一个新文件, 且未发生别的跳转, 此时, `<C-o>`是可以切换到上一个文件的. 那么, `vim`的跳转包括叼些呢?

* `(/)`跳转到上一句/下一句的开头. `{/}`跳转到上一段/下一段的开头. 
* `H/M/L`跳转到屏幕的上方/正中间/最下方.
* `gf`跳转到光标下的文件名, 必须是当前路径下开始算起. `<C-]>`跳转到光标下单词的标签.
* `\`{mark}`和`'{mark}`跳转到一个位置标记.
* `%`跳转到匹配的括号处.
* `/?`搜索, 和相应的`n/N`.
* `[count]G`指定行跳转.


跳转列表独立于窗口和标签, 对于缓冲区, 同窗口同标签的情况下, 多缓冲区是共享一个跳转列表.

除了跳转列表`:ju[mps]`外, 还有改变列表`:changes`.
